## 기본 데이터 처리
### 풀 테이블 스캔 & 풀 인덱스 스캔
- Read ahead - innodb
  - 어떤 영역의 데이터가 앞으로 필요할지 예측해서 미리 버퍼 풀에 가져다 둔다.
  - 처음 몇개의 데이터는 클라이언트 스레드가 페이지를 읽고 이후부턴 백그라운드 스레드로 넘김

### 병렬 처리
- where 조건이 없는 단순한 쿼리는 하나의 쿼리를 여러 스레드가 나누어 동시에 처리 가능

### ORDER BY 처리
- 인덱스의 정렬을 사용하는 방법 / Filesort라는 별도의 처리를 이용하는 방법 (실행계획 - Using filesort)

#### 소트 버퍼
- 정렬을 위해 할당받는 별도의 메모리 공간
- 정렬할 레코드가 소트버퍼 공간보다 크다면 병합작업 필요
  - 멀티머지: 소트버퍼에서 정렬 후 디스크에 임시저장 반복
 
#### 정렬 알고리즘
- 소트버퍼에 레코드 전체를 담을지 정렬기준 컬럼만 담을지에 따라 나뉜다.
- 싱글 패스
  - 정렬기준 컬럼을 포함해 컬럼 전부를 담아서 정렬 수행
  - 정렬대상 레코드가 작을 경우 유리
- 투 패스
  - 정렬대상 컬럼과 pk값만 담아서 정렬 수행하고 정렬된 순서대로 다시 pk키로 조회하는 방식
  - 정렬대상 레코드가 클 경우 유리

<br>
<br>
<br>

- 정렬 처리 속도
  - 인덱스 > 조인 > 임시테이블
- b tree 계열이 아니면 인덱스 정렬 사용못한다.
- 인덱스 정렬만 스트리밍 처리 형태 사용 가능하다.
- 드라이빙 테이블에 속한 컬럼만으로 그루핑할때 대체로 임시테이블 사용하지 않는다.
- 8.0 부터 group by에 묵시적 정렬은 수행되지 않는다.
- distinct는 특정 컬럼만 유니크하게 조회하는것이 아니다.
- 임시테이블도 트랜잭션 지원: 메모리(temp table), 디스크(innodb)
- union all이 더이상 항상 임시테이블을 사용하지 않음
- MRR: 조인을 즉시실행하지 않고, 조인 대상을 버퍼링 하는 것.
- 드리븐테이블의 풀스캔을 피할 수 없으면 드라이빙 테이블 레코드를 메모리에 캐시한 후 드리븐테이블과 조인
  - 조인버퍼: 이때 사용되는 메모리 캐시
- 세컨더리 인덱스는 대상 컬럼과 리프노드의 pk를 포함한 조합으로 인덱스를 생성한것과 흡사하게 동작한다.
- 인덱스 머지: 2개이상의 인덱스로 쿼리를 처리
- 세미조인: where절 서브쿼리가 먼저 실행되지 않고 기존 테이블 풀스캔 후 서브쿼리결과에 맞는지 한건한건 매핑
- 더이상 서브쿼리를 조인으로 풀어서 작성안해도 된다.
- 조인 시 일치하는 조건이 적은 테이블을 드라이빙테이블로 설정하는게 중요.
- 가능하면 서브쿼리는 외부쿼리로 수동으로 병합해서 작성하는게 좋다.
- 8.0 부터 멀티인덱스의 첫번째 값이 없어도 선행 컬럼의 조건이 적으면 인덱스를 이용한 쿼리성능개선이 가능하다.
- 해시조인은 긴 스루풋 전략에, 네스티드 루프 조인은 빠른응답속도 전략에 유용하다.
  - 일반적인 웹서비스의 경우 네스티드 루프조인이 유리하다. 그외에는 애초에 mysql을 선택하지 않을것이다.
- 조인 테이블의 수가 늘어날수록 실행계획수립의 소요되는 시간도 선형적으로 증가한다.
- mysql서버에 쿼리힌트를 제공할 수 있다. (인덱스 힌트, 옵티마이저 힌트 ...)
  - 조인 순서 변경, 인덱스 힌트, 테이블 수준 ...
  - 가능한 옵티마이저 힌트를 사용하는걸 추천




















# mysql 엔진 아키텍처
- mysql 서버는 다른 DBMS에 비해 구조가 독특하다.
- 다른 DBMS에 비해 장단점이 존재한다.

<br>

## mysql 전체 구조
- mysql 서버
  - mysql 엔진
    - 클라이언트로부터 접속 및 쿼리요청을 처리하는커넥션 핸들러
    - SQL 파서 및 전처리기
    - 쿼리의 최적화된 실행을 위한 SQL 옵티마이저
  - 스토리지 엔진
    - InnoDB, MyISAM, Memory
    - 실제 데이터를 디스크 스토리지에 저장하거나 읽어오는 역할을 담당.
    - mysql 엔진은 하나지만 스토리지 엔진은 여러개를 동시에 사용할 수 있다.
    - 처음 스토리지 엔진을 지정하면 이후 테이블의 모든 작업은 정의된 엔진이 처리한다.
  - 운영체제 하드웨어
    - 디스크: 데이터 파일, 로그 파일

<br>

### 핸들러 API
- mysql 엔진의 쿼리 실행기에서 데이터를 읽기/쓰기 할때 스토리지 엔진에 읽기/쓰기 요청을 한다.
- 이걸 핸들러 요청이라 부르고 여기에 사용되는 API를 핸들러 API라고 함.

<br>

## mysql 스레딩 구조
프로세스 기반이 아닌 스레드 기반으로 동작

### 포그라운드 스레드 (클라이언트 스레드)
- 최소한 mysql서버에 접속한 클라이언트 수 만큼 존재
- 주로 클라이언트 사용자가 요청하는 쿼리문장을 처리한다.
- innodb는 데이터 버퍼&캐시 까지만 처리하고 버퍼에서 디스크로 기록하는 작업은 백그라운드 스레드가 담당.

### 백그라운드 스레드
- innodb에서의 역할
  - 인서트 버퍼를 병합하는 스레드
  - 로그를 디스크로 기록하는 스레드
  - 버퍼풀의 데이터를 디스크에 기록하는 스레드
  - 데이터를 버퍼로 읽어오는 스레드
  - 잠금이나 데드락을 모니터링하는 스레드
- 읽기 스레드는 주로 클라이언트 스레드가 담당하지만 쓰기 스레드는 아주 많은 작업을 백그라운드로 처리한다.
- myisam은 사용자스레드가 쓰기작업까지 담당하지만 innodb는 쓰기작업을 버퍼링해 일괄처리 한다.
  - myisam: 일반적인 쿼리는 쓰기 버퍼링 기능 사용 불가.
  - innodb는 insert, update, delete쿼리로 데이터가 변경될때 완전히 저장될때까지 기다리지 않아도 된다.
  - 즉, innodb는 읽기작업을 절대 지연하지 않으려고 노력한다.
 
<br>

## 메모리 할당 및 사용 구조
### 글로벌 메모리 영역
- mysql서버가 시작되면서 운영체제로부터 할당된다.
- 클라이언트 스레드 수와 무관하게 할당된다.
  - 테이블 캐시
  - innodb 버퍼 풀
  - innodb 어댑티브 해시 인덱스
  - innodb 리두로그 버퍼
 
### 로컬 메모리 영역
- 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역, 세션 메모리 영역이라고도 부름
- 스레드별로 독립적으로 할당되며 공유되지 않는다.
  - 정렬 버퍼
  - 조인 버퍼
  - 바이너리 로그 캐시
  - 네트워크 버퍼
 
<br>

## 플러그인 스토리지 엔진 모델
- 다양한 요구사항의 기능을 제공하는 스토리지 엔진 플러그인 (직접 개발 가능)
  - 쿼리실행의 대부분이 mysql엔진에서 처리되기 때문에 직접 개발해도 일부분의 기능만 수행하는 엔진을 작성하게 된다.
- mysql엔진이 스토리지 엔진을 콜하려면 반드시 핸들러를 통해야 한다.
- 8.0부터 플러그인 아키텍처를 대체하기 위해 컴포넌트 아키텍처가 지원된다.

<br>

## 쿼리 실행 구조
1. 쿼리 파서
   - 요청으로 들어온 쿼리문장을 mysql이 인식할 수 있는 트리 형태의 구조로 만들어 냄
   - 쿼리문의 문법오류는 이과정에서 발견됨
2. 전처리기
   - 파서과정에서 만들어진 파서트리를 기반으로 쿼리문장에 구조적인 문제점이 있는지 확인.
   - 테이블이름, 컬럼이름, 내장함수 등의 존재 여부와 접근권한등을 확인
3. 옵티마이저
   - 쿼리문을 가장 효율적으로 어떻게 처리할지 결정하는 역할
4. 실행 엔진
   - 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또다른 핸들러 요청의 입력으로 연결하는 역할
5. 핸들러(스토리지 엔진)
   - 실행엔진의 요청에 따라 데이터를 디스크로 저장, 읽어오는 역할
  
<br>

## 쿼리 캐시
- 테이블의 데이터가 변경되면 캐시에 저장된것들이 모두 삭제되어야 하기 때문에 동시 처리 성능 저하와 버그의 원인이었다.
- 8.0 버전부터 삭제되었다.

<br>

## 트랜잭션 지원 메타데이터
- 8.0 부터 테이블 구조정보, 스토어드 프로그램 코드 관련정보는 모두 innodb의 테이블에 저장된다.
  - 스키마 변경 작업중간에 mysql 서버가 다운되도 성공 또는 실패로 정리된다.

<br>

# innodb 스토리지 엔진 아키텍처
mysql엔진 중 거의 유일하게 레코드 기반 잠금을 제공하고 높은 동시성처리와 안정적이고 성능이 좋다.

## 프라이머리 키에 의한 클러스팅
- innodb의 모든 테이블은 프라이머리 키 값 순서대로 디스크에 저장된다.
- 모든 세컨더리 인덱스는 프라이머리 키 값을 논리적 주소로 사용한다.
- 덕분에 프라이머리 키를 이용한 레인지 스캔은 상당히 빠르다.
- myisam 에선 프라이머리 키는 유니크 제약을 가진 세컨더리 인덱스일 뿐이다.

## 외래 키 지원
- 부모/자식 테이블 모두 해당 컬럼에 인덱스 생성 필요
- 변경 시 더블체크로 인해 잠금이 여러 테이블로 전파되고, 그로인한 데드락이 발생할 때가 많음
- 수동으로 데이터 적재나 스키마 변경 시 복잡하게 얽힌 외래 키로 인해 실패할 수 있다.

## MVCC (Multo Version Concurrency Control)
- 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는 데 있다.
- innodb에서는 언두 로그를 이용해 이 기능을 구현한다.
- 조회 시 격리 수준에 따라 버퍼 풀 또는 언두영역에서 데이터를 가져온다.
  - serializable이 아니면 insert와 연결되지 않은 순수한 읽기 작업은 바로 실행된다.
- 롤백 시에도 언두영역의 데이터를 사용한다.

## 자동 데드락 감지
- 데드락 감지 스레드가 주기적으로 검사해 교착상태의 트랜잭션을 찾아 그중 하나를 강제 종료한다.
  - 언두로그 레코드를 더 적게 가진 트랜잭션을 강제종료 한다.


















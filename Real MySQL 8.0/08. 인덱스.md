### 랜덤 I/O & 순차 I/O
- 디스크 헤더를 옮겨서 데이터를 읽는 랜덤 I/O가 훨씬 더 느리다.
- 데이터베이스 대부분의 작업은 작은 데이터를 빈번히 읽고 쓰는 랜덤 I/O작업이다.
- 디스크 원판을 가지지 않는 SSD 드라이브 에서도 랜덤 I/O가 느리다.
- 일반적인 쿼리튜닝은 랜덤 I/O 자체를 줄여주는 목적이 크다.

### B-TREE
- 인덱스와 실제 데이터가 저장된 데이터는 따로 관리된다.
  - INNODB에서는 데이터 파일 레코드도 클러스터(최대한 비슷한 값을 모아서 저장하는 방식)되어 PK순으로 저장된다.
- 루트 노드 - 브랜치 노드 - 리프 노드
- PK, UK의 경우 즉시 추가나 삭제되어야 하지만 다른 인덱스는 체인지버퍼에 의해 지연할 수 있다.
- 조회의 경우 일치 또는 값의 앞부분만 일치할 경우 인덱스를 타고 값의 뒷부분일 경우 탈 수 없다.
- 함수나 연산에 대한 결과는 B-TREE를 탈 수 없다.
- 인덱스 키 값의 크기는 가능하면 작게 만드는 것이 좋다.
  - 하나의 인덱스 페이지에는 여러개의 키가 저장될 수 있고, 인덱스 키 값의 크기에 따라 가변적이다.
- 인덱스를 통해 레코드를 읽는것은 직접 레코드를 읽는 비용보다 보통 4~5배의 비용이 든다.
  - 인덱스를 통하는 레코드 건수가 전체 테이블 레코드의 20~25%를 넘을 겨우 직접 읽고 필터링 하는게 더 효율적이다.

### 인덱스 스캔
- 레인지 스캔
  - 리프노드의 시작점을 찾아가면 그 뒤로 리프노드의 레코드만 순서대로 읽으면 된다.
    - 리프 노드 간의 링크 활용, 인덱스 자체의 정렬 활용
    - 커버링 인덱스의 경우 레코드를 읽어오는 과정(랜덤I/O)이 필요없다.
      - 커버링 인덱스 : 데이터를 인덱스에서만 추출(쿼리를 충족)할 수 있는 인덱스
- 인덱스 풀스캔
  - 인덱스의 처음부터 끝까지 모두 읽는 방식 (리프노드의 링크드리스트를 타고 쭉)
    - 대표적으로 조건절에 사용된 컬럼이 인덱스의 첫 번쨰 컬럼이 아닐경우
- 루스 인덱스 스캔
  - 레인지 스캔과 비슷하게 동적하지만 중간에 필요하지 않은 인덱스는 스킵하는 형태
  - 일반적으로 group by, min, max 함수의 최적화를 하는 경우
- 인덱스 스킵 스캔
  - index(gender, birth_day) 에서 조건절 맨앞에 gender가 없어도 인덱스 스캔이 되는 방식
  - 예를들어, 조건절에 gender가 없어도 내부적으로 m, f 두개를 넣어 2개 쿼리를 실행함
    - 선행 컬럼의 유니크한 값의 개수가 적어야 함
    - 커버링 인덱스 이어야 함
  













  

### 키-값 저장소
* 키는 유일해야 하고, 짧을수록 좋다.
* 보통 value의 타입은 다양하다.
* ex) 아마존 다이나모, 레디스

<br>

### 단일 서버 키-값 저장소
* 키-값 쌍 정부를 메모리에 해시테이블로 저장
  * 데이터 압축
  * 캐시히트가 높은 데이터만 저장

<br>

### 분산 키-값 저장소
#### CAP 정리
데이터 일관성, 가용성, 파티션 감내 이 세 가지 요구사항을 동시에 만족하는 분산 시스템을 설계하는건 불가능하다는 정리
* 데이터 일관성: 모든 클라이언트는 어떤 노드에 접속했냐에 상관없이 항상 같은데이터를 봐야 한다.
* 가용성: 클라이언트는 일부 노드에 장애가 발생해도 항상 응답을 받아야 한다.
* 파티션 감내: 네트워크에 파티션이 생겨도 시스템은 계속 동작해야 한다.
  * 파티션: 두 노드 사이에 통신장애가 발생한 상황
 
<br>

### 핵심 컴포넌트
#### 데이터 파티션
데이터를 작은 파티션으로 분할한 후 여러 대의 서버에 저장
* 데이터를 고르게 분산
* 노드의 추가/삭제 시 데이터 이동을 최소화
5장에서 배운 안정해시가 솔루션이 될 수 있다.

<br>

#### 데이터 다중화
데이터를 N개의 서버에 비동기로 다중화
* 노드를 선택할 때, 같은 데이터 센터는 피하자.

<br>

#### 데이터 일관성
여러 노드에 다중화된 데이터는 적절히 동기화 되어야 한다.

<br>

#### 일관성 모델
* 강한 일관성: 모든 읽기연산은 가장 최근에 갱신된 결과를 반환한다.
  * 모든 사본에 동기화 되기 전까지 해당 데이터에 읽기/쓰기를 금지
  * 고가용성 X
* 약한 일관성: 읽기연산은 가장 최근에 갱신된 결과를 반환하지 못할 수 있다.
* 결과적 일관성: 갱신결과가 결국 모든 사본에 동기화 되는 모델
  * 많이 채택된다.
  * 병렬적 쓰기 연산으로 인해 일관성이 깨질 수 있지만 버전정보등을 활용해 책임을 클라이언트에게 전가

<br>

#### 비일관성 해소 기법
* 데이터 버저닝: 데이터를 변경할 때마다 버전을 만든다. 버전의 데이터는 불변이다.
* 벡터 시계: 서버, 버전의 순서쌍을 데이터에 기록

<br>

#### 가십 프로토콜
분산형 장애 감지 솔루션
* 각 노드는 멤버 id와 박동카운터 쌍의 목록인 멤버십 목록을 유지한다.
* 각 노드는 주기적으로 자신의 박동 카운터를 증가시키고 랜덤으로 다른 노드에게 박동카운터 목록을 보낸다.
* 박동 카운터 목록을 받은 노드는 멤버십 목록을 최신으로 갱신한다.
* 어떤 멤버의 박동 카운터 값이 지정된 시간동안 갱신이 안되면, 장애로 간주한다.

<br>

### 요약

| 목표/문제 | 기술  |
|-------|----------|
| 대규모 데이터 저장 | 안정해시를 사용해 서버들에 분산   |
| 읽기 연산의 가용성 | 여러 데이터센터에 다중화 |
| 쓰기 연산의 가용성 | 버저닝/벡터시계를 사용해 충돌 해소    |
| 데이터 파티션 | 안정해시  |
| 점진적 규모 확장 | 안정해시  |
| 다양성 | 안정해시  |
| 조절가능한 데이터 일관성 | 정족수 합의 프로토콜  |
| 일시적 장애 처리 | 느슨한 정족수 프로토콜, 단서 후 임시위탁  |
| 영구적 장애 처리 | 머클 트리  |
| 데이터 센터 장애 대응 | 여러 데이터 센터에 데이터 다중화  |








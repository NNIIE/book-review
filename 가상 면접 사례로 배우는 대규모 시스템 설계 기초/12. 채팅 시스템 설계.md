## 메시지 수신 시나리오
### 폴링
* 클라이언트가 주기적으로 서버에게 요청
* 자주할수록 비용이 올라가며, 답해줄 메시지가 없는경우 서버자원 낭비

### 롱 폴링
* 클라이언트는 새 메시지가 반환되거나 타임아웃 날때까지 연결을 유지
* 새 메시지를 받으면 기존 연결을 종료하고, 처음부터 다시 시작

### 웹소켓
* 클라이언트가 연결을 시작하고, 맺어진 연결은 양방향이다.
* 처음은 HTTP 연결이지만 특정 핸드셰이크 절차를 거쳐 웹소켓 연결로 업그레이드
* 웹소켓 연결은 항구적으로 유지되어야 하기 때문에 서버측에서 연결관리를 효율적으로 해야 함.

<br>

## 개략적 설계안
### 무상태 서비스

### 상태 유지 서비스
* 각 클라이언트가 채팅서버와 독립적인 네트워크 연결을 유지
* 서비스 탐색 서비스는 특정 서버에 부하가 몰리지 않도록 한다.

### 제3자 서비스 연동
* 앱이 실행중이지 않더라도 알림을 받을 수 있는 푸시 알림

### 규모 확장성
실시간으로 메시지를 주고받기 위해 클라이언트는 채팅 서버와 웹소켓 연결을 유지
* 채팅서버: 클라이언트 사이에 매시지를 중계하는 역할
* 접속상태 서버: 사용자의 접속 여부 판단
* API 서버: 로그인, 회원가입 등 나머지 전부를 처리
* 알림 서버: 푸시알림
* 키-값 저장소: 채팅 이력 보관

### 저장소
채팅시스템이 다루는 데이터 종류
* 프로파일, 설정, 친구 목록
  * 관계형 디비에 저장
  * 레플리케이션, 샤딩 등으로 가용성과 규모확장성 확보
* 채팅 이력
  * 가장 빈번하게 사용되는건 최근에 주고받은 메시지
  * 검색, 특정사용자가 언급된 메시지, 특정 메시지로 점프 등 무작위 데이터 접근도 지원해야 함.
  * 1:1 채팅앱의 경우 읽기/쓰기 비율은 대략 1:1이다.
  * 키-값 저장소 추천
    * 수평적 규모확장에 용이
    * 데이터 접근 지연시간이 낮음
    * 관계형디비는 인덱스가 커지면 무작위 접근에 비용이 늘어남.

<br>

## 상세 설계
### 서비스 탐색
* 클라이언트에게 가장 적합한 채팅 서버를 추천하는 역할
  * 기준으로 클라이언트 위치, 서버용량 등
  * ex) 아파치 주키퍼

### 메시지 흐름
#### 1:1 채팅
1. A가 채팅서버 1로 메시지 전송
2. 채팅서버 1은 ID생성기로 해당 메시지의 ID결정
3. 채팅서버 1은 해당 메시지를 메시지 동기화 큐로 전송
4. 메시지가 키-값 저장소에 보관됨
5. 메시지는 B가 접속중이면 접속중인 채팅서버로 아니면 푸시알림 서버로 보낸다.
6. 채팅서버 2는 메시지를 B에게 전송. B와 채팅서버2는 웹소켓 연결이 있으므로 그것을 이용

### 접속상태 표시
#### 로그인/로그아웃
* 클라이언트와 실시간 서비스 사이에 웹소켓 연결이 맺어진다.
* 접속상태 서버는 A의 상태와 타임스탬프 값을 키-값 저장소에 보관한다.
* 이 절차가 끝나면 접속중/로으아웃 인것으로 표시

#### 접속 장애
* 온라인상태의 클라이언트는 박동이벤트를 접속상태 서버로 보낸다.







## 개략적 설계안
### API 서버
* 업로드 API
  * 단순 업로드: 작은 파일
  * 이어 올리기: 큰 파일
* 다운로드 API
* 파일 갱신 히스토리 API
* 사용자 인증과 HTTPS 프로토콜 사용

### 한대 서버의 제약 극복
* S3 스토리지 사용
* scale-out
* 메타데이터 데이터베이스, 레플리케이션, 샤딩 적용
* 2개 이상에 파일저장소를 다중화

### 동기화 충돌
* 먼저 처리되는 변경은 성공, 나중에 처리되는 변경은 충돌이 발생한것으로 표시

<br>

## 개략적 설계안
* 사용자 단말
* 블록 저장소 서버: 파일블록을 클라우드 저장소에 업로드하는 서버
* 클라우드 저장소
* 아카이빙 저장소: 오랫동안 사용되지 않은 비활성 데이터 용
* 로드밸런서
* API 서버
* 메타데이터 디비/캐시
* 알림 서비스
* 오프라인 사용자 백업 큐: 접속중이 아닐 때, 해당 정보를 이 큐에 둬서 접속했을때 동기화

<br>

## 상세 설계
### 블록 저장소 서버
* 델타 동기화: 수정된 블록만 동기화
* 압축: 블록 단위 압축
1. 주어진 파일을 작은 블록들로 분할
2. 각 블록 압축
3. 암호화
4. 클라우드 저장소에 전송

### 높은 일관성 요구사항
* 캐시된 데이터와 디비의 원본이 일치해야 함.
* 디비의 원본이 변경되면 캐시 무효화
* ACID를 지원하는 RDBMS 채택

### 업로드 절차
1. 파일 메타데이터 추가
2. 파일을 클라우드 저장소에 업로드

### 다운로드 절차
* 접속중일때 파일이 변경되면 새 버전을 끌어가야 한다고 알린다.
* 접속중이 아니면 데이터는 캐시에 보관되고 접속하면 그때 새 버전을 가져감

### 알림 서비스
* 롱 폴링
  * 양뱡향 통신이 필요하지 않아 채택
* 웹소켓

### 저장소 공간 절약
* 중복제거: 해시값을 비교하여 중복된 파일블록을 계정차원에서 제거
* 백업전략
  * 한도설정
  * 중요한 버전만 보관
* 자주 쓰이지 않는 데이터는 아카이빙 저장소 활용












## 카프카 브로커, 클러스터, 주키퍼
* 3대이상의 브로커 서버를 1개의 클러스터로 묶어 사용
  * 하나의 서버에는 하나의 브로커 프로세스 실행
* 클러스터로 묶인 브로커들은 프로듀서가 보낸 데이터를 안전하게 분산 저장하고 복제하는 역할을 수행

### 데이터 저장, 전송
* 브로커는 프로듀서가 요청한 토픽의 파티션에 데이터를 저장, 컨슈머가 데이터를 요청하면 파티션에 저장된 데이터 전달
  * 데이터는 파일시스템에 저장
  * 페이지 캐시를 사용하여 파일시스템이어도 빠른 속도를 보장, 덕분에 브로커 힙사이즈를 크게 가져갈 필요없음

### 데이터 복제, 싱크
* 복제는 카프카가 장애허용시스템으로 동작하도록 함
* 슬레이브-마스터 구조처럼 리더-팔로워 구조로 되어있다.

### 컨트롤러
* 클러스터의 브로커중 한대가 컨트롤러의 역할을 한다.
* 다른 브로커들의 상태를 체크하고 재분배하는 역할

### 데이터 삭제
* 삭제는 오직 브로커만 가능.
* 삭제는 파일단위로 이루어짐
* 삭제하지 않고 오래된 데이터를 압축하는 정책을 가져갈 수 있다.

### 컨슈머 오프셋 저장
* 컨슈머 그룹은 파티션의 데이터를 어디까지 읽어갔는지 확인하기 위해 오프셋을 커밋한다.

### 코디네이터
* 컨슈머 크룹의 상태를 체크하고 파티션을 컨슈머와 매칭되도록 분배하는 역할
* 다수의 브로커 중 한대는 코디네이터 역할을 수행한다.

### 주키퍼
* 카프카의 메타데이터를 관리한다
  * 어떤 보안규칙으로 통신하는지, jmx port 상태, host 정보 등
  * 어느 브로커가 컨트롤러인지
  * 카프카에 저장된 토픽들

<br>

## 토픽과 파티션
* 토픽은 1개 이상의 파티션을 소유한다
* 파티션은 pop없는 queue
* **같은 그룹으로 묶인 컨슈머 개수와 파티션개수를 스케일 아웃해서 병렬처리량 증가**

<br>

## 레코드
* 타임스탬프, 메시지 key-value, 오프셋, 헤더로 구성
* 브로커에 한번 적재된 레코드는 수정할 수 없다.

<br>

## 카프카 클라이언트
### 프로듀서
* send -> 파티션 결정 -> 버퍼에 저장 -> 배치 발송

### 컨슈머
* 운영방법은 크게 2가지 이다.
  * 1개이상의 컨슈머로 이루어진 컨슈머 그룹을 운영
    * 토픽의 1개 이상 파티션들에 할당되어 데이터를 가져간다.
    * 컨슈머 그룹끼리는 격리된다.
    * 컨슈머 그룹의 컨슈머 개수는 대상 토픽의 파티션 개수 이하여야 한다.
    * 일부 컨슈머에 장애가 발생하면 컨슈머에 할당된 파티션은 정상적인 컨슈머에 소유권이 넘어간다.
  * 토픽의 특정 파티션만 구독하는 컨슈머 운영
* 데이터 유실을 허용하지 않는 서비스는 오프셋 오토커밋을 사용해서는 안된다.
* 컨슈머는 타임아웃이 발생하지 않게 안전하게 종료되어야 한다.

<br>

## 카프카 스트림즈
카프카에서 공식 지원하는 토픽에 적재된 데이터를 상태기반 & 비상태기반으로 실사간 변환하여 다른 토픽에 적재하는 라이브러리
* 자바 라이브러리로 구현하는 스트림즈 어플리케이션은 JVM위에서 하나의 프로세스로 실행됨.


















